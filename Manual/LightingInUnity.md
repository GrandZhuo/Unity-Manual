<!-- # Lighting overview -->
# 光照概述

<!-- In order to calculate the shading of a 3D object, Unity needs to know the intensity, direction and color of the light that falls on it. -->

为了计算 3D 对象的着色，Unity 需要知道落在 3D 对象的光的强度、方向和颜色。


![](https://docs.unity3d.com/uploads/Main/LightBasic.svg)

<!-- These properties are provided by Light objects in the scene. Different types of light emit their assigned color in different ways; some lights may diminish with distance from the source, and have different rules about the angle of light received from the source. The different types of light source available in Unity are detailed in [Types of light]. -->

这些属性由场景中的灯光对象提供。不同类型的灯光以不同的方式发射为它们分配的颜色；某些光可以随着与光源的距离而衰减，并且接受的光线角度也有不同的规则。Unity 提供的各种光源在 [灯光类型] 中有详细说明。

[Types of light]: https://docs.unity3d.com/Manual/Lighting.html
[灯光类型]: https://docs.unity3d.com/Manual/Lighting.html

<!-- Unity can calculate complex, advanced lighting effects in various different ways, each suited to different use cases. -->

Unity 以多种不同的方式计算复杂的、高级的光照效果，每种方式对应不同的场景。

<!-- ## Choosing a lighting technique -->
## 选择光照方案

<!-- Broadly speaking, lighting in Unity can be considered as either ‘realtime’ or ‘precomputed’ in some way and both techniques can be used in combination to create immersive scene lighting. -->

Unity 中的光照可以粗略地分为『实时』和『预计算』，并且，两种光照可以组合使用，以创建沉浸式的场景光照。

<!-- In this section we will give a brief overview of what opportunities the different techniques offer, their relative advantages and individual performance characteristics. -->

在本节中，我们将简要概述不同技术的适用场景、相对优势，以及独特的性能因素。

<!-- ## Realtime lighting -->
## 实时光照

<!-- By default, lights in Unity - directional, spot and point, are realtime. This means that they contribute direct light to the scene and update every frame. As lights and GameObjects are moved within the scene, lighting will be updated immediately. This can be observed in both the scene and game views. -->

默认情况下，Unity 中的灯光 —— 平行光、聚光灯和点光源 —— 是实时的。这意味着，它们为场景提供直接光照，并且每桢更新。如果灯光和游戏对象在场景中移动，光照将立即更新。在场景视图和游戏视图中都可以观察这种变化。

<!-- Realtime LightsThe effect of realtime light alone. Note that shadows are completely black as there is no bounced light. Only surfaces falling within the cone of the Spotlight are affected. -->

注意，因为没有弹射光，所以阴影是完全黑色的。只有位于聚光灯椎体内的表面才会收到影响。

> 译注：原文有错误，这里应该有一张截图，展示一个聚光灯的实时效果。

<!-- Realtime lighting is the most basic way of lighting objects within the scene and is useful for illuminating characters or other movable geometry. -->

实时光照是照亮场景中物体的最基本方式，可以用于照亮角色或其他可移动的几何物体。

<!-- Unfortunately, the light rays from Unity’s realtime lights do not bounce when they are used by themselves. In order to create more realistic scenes using techniques such as global illumination we need to enable Unity’s precomputed lighting solutions. -->

不幸的是，在 Unity 中，来自实时光的光线不会被弹射。为了使用诸如全局光照等技术，创建更加逼真的场景，我们需要使用 Unity 的预计算光照方案。

<!-- ## Baked lightmaps -->
## 烘培光照贴图

<!-- Unity can calculate complex static lighting effects (using a technique called global illumination, or GI) and store them in a reference texture map called a lightmap. This calculation process is referred to as baking. -->

Unity 可以计算复杂的静态光照效果（使用称为全局光照或 GI 的技术），并将它们存储在一张称为光照贴图的纹理文件中。这个计算过程成为『烘培』。

<!-- When baking a lightmap, the effects of light sources on static objects in the scene are calculated and the results are written to textures which are overlaid on top of scene geometry to create the effect of lighting. -->

烘培光照贴图时，场景中静态对象上的光源效果被计算，并将计算结果写入覆盖了场景几何顶点的纹理文件中，以产生光照效果。

![Left: A simple lightmapped scene. Right: The lightmap texture generated by Unity. Note how both shadow and light information is captured.](https://docs.unity3d.com/uploads/GlobalIllumination/Lightmap.png)
<!-- > Left: A simple lightmapped scene. Right: The lightmap texture generated by Unity. Note how both shadow and light information is captured. -->
> 左图：一个简单的光照贴图场景。右图：Unity 生成的光照贴图纹理。注意是如何捕获阴影和灯光信息的。


<!-- These lightmaps can include both the direct light which strikes a surface and also the indirect light that bounces from other objects or surfaces within the scene. This lighting texture can be used together with surface information like color (albedo) and relief (normals) by the Shader associated with an object’s material. -->

光照贴图可以包含撞击到表面的直接光和场景中其他对象或表面弹射的间接光。光照贴图可以和表面信息结合使用，例如对象的材质着色器指定的颜色（漫反射）和浮雕（法线）。

<!-- With baked lighting, these lightmaps cannot change during gameplay and so are referred to as ‘static’. Realtime lights can be overlaid and used additively on top of a lightmapped scene but cannot interactively change the lightmaps themselves. -->

使用烘培照明时，光照贴图在游戏期间无法改变，因为被称为是『静态』的。实时灯光可以叠加在光照贴图之上，但是无法改变光照贴图本身。

<!-- With this approach, we trade the ability to move our lights at gameplay for a potential increase in performance, suiting less powerful hardware such as mobile platforms. -->

当在游戏过程中移动灯光时，使用这种方法可以潜在地提升性能，以适配性能不佳的硬件，例如移动平台。

<!-- See [the Lighting window reference] and [Using precomputed lighting] for more information. -->

更多信息请参阅 [光照视图参考页] 和 [使用预计算光照] 。

[the Lighting window reference]: https://docs.unity3d.com/Manual/GlobalIllumination.html
[Using precomputed lighting]: https://docs.unity3d.com/Manual/UsingPrecomputedLighting.html
[光照视图参考页]: https://docs.unity3d.com/Manual/GlobalIllumination.html
[使用预计算光照]: https://docs.unity3d.com/Manual/UsingPrecomputedLighting.html

<!-- ## Precomputed realtime global illumination -->
## 预计算的实时 GI

<!-- Whilst static lightmaps are unable to react to changes in lighting conditions within the scene, precomputed realtime GI does offer us a technique for updating complex scene lighting interactively. -->

虽然静态光照贴图不能对场景中光照条件的变化做出响应，但是，预计算实时 GI 技术可以支持交互式地更新复杂场景的光照。

<!-- With this approach it is possible to create lit environments featuring rich global illumination with bounced light which responds, in realtime, to lighting changes. A good example of this would be a time of day system - where the position and color of the light source changes over time. With traditional baked lighting, this is not possible. -->

使用这种技术，可以创建具有丰富全局光照的场景，并且可以实时地响应弹射光和光照变化。一个很好的例子是昼夜系统 —— 光源的位置和颜色随着时间变化。而使用传统的烘培光照技术是不可能实现的。

![A simple example of time of day using Precomputed Realtime GI.](https://docs.unity3d.com/uploads/GlobalIllumination/timeofdaycycle.gif)
<!-- > A simple example of time of day using Precomputed Realtime GI. -->
> 简单的昼夜示例，使用了预计算实时 GI。

<!-- In order to deliver these effects at playable framerates, we need to shift some of the lengthy number-crunching from being a realtime process to one which is precomputed. -->

为了在可玩帧率下实现这些效果，我们需要将一些冗长的数字解调从实时处理转移到预计算过程中。

<!-- Precomputing shifts the burden of calculating complex light behaviour from something that happens during gameplay, to something which can be calculated when time is no longer so critical. We refer to this as an ‘offline’ process. -->

预计算把游戏过程中计算复杂光照行为的过程，转移到不重要的时间段进行处理。我们称之为『离线』处理。

<!-- For further information, please see the [lighting and rendering tutorial]. -->

更多信息请参阅 [关照和渲染教程] 。

[lighting and rendering tutorial]: http://unity3d.com/learn/tutorials/topics/graphics/unity-5-lighting-and-rendering?playlist=17102
[关照和渲染教程]: http://unity3d.com/learn/tutorials/topics/graphics/unity-5-lighting-and-rendering?playlist=17102

<!-- ## Benefits and costs -->
## 利与弊

<!-- Although it is possible to simultaneously use Baked GI lighting and Precomputed Realtime GI, be wary that the performance cost of rendering both systems simultaneously is exactly the sum of them both. Not only do we have to store both sets of lightmaps in video memory, but we also pay the processing cost of decoding both in shaders. -->

尽管可以同时使用烘培 GI 和预计算实时 GI，但要注意，同时渲染两个系统的性能成本恰好是它们的总和。我们不仅需要在显存中存储两种光照贴图，还需要支付着色器解码它们的成本。

<!-- The cases in which you may wish to choose one lighting method over another depend on the nature of your project and the performance capabilities of your intended hardware. For example, on mobile where video memory and processing power is more limited, it is likely that a Baked GI lighting approach would be more performant. On standalone computers with dedicated graphics hardware, or recent games consoles, it is quite possible to use Precomputed Realtime GI or even to use both systems simultaneously. -->

选择和放弃哪种光照方案，取决于项目性质和硬件性能预期。例如，移动设备的显存和处理能力有限，烘培 GI 方案可能更加高效。在具有专用图形硬件的独立计算机上，或最新的游戏机上，很可能使用预计算实时 GI 方案，甚至同时使用两种方案。

<!-- The decision on which approach to take will have to be evaluated based on the nature of your particular project and desired target platform. Remember that when targeting a range of different hardware, that often it is the least performant which will determine which approach is needed. -->

关于采用哪种方案，必须基于特定项目的性质和目标平台进行评估。请记住，当定位于（需要支持）一系列不同的硬件时，通常性能最差的硬件能将决定需要哪种方案。

<!-- See also: [Light Troubleshooting and Performance] -->

另请参阅 [灯光故障排除和性能] 。

[Light Troubleshooting and Performance]: https://docs.unity3d.com/Manual/LightPerformance.html
[灯光故障排除和性能]: https://docs.unity3d.com/Manual/LightPerformance.html
